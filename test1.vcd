$date
	Mon May 16 20:56:46 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testBench $end
$var wire 32 ! aluResult [31:0] $end
$var wire 4 " aluctrl [3:0] $end
$var wire 9 # ctrlUnitOutCode [8:0] $end
$var wire 32 $ dmOutData [31:0] $end
$var wire 32 % extSign32 [31:0] $end
$var wire 32 & imOutData [31:0] $end
$var wire 32 ' mw32Out [31:0] $end
$var wire 32 ( pcOutAddr [31:0] $end
$var wire 32 ) reg1Data [31:0] $end
$var wire 32 * reg2Data [31:0] $end
$var wire 32 + writeData [31:0] $end
$var wire 5 , writeReg [4:0] $end
$var reg 1 - clk $end
$var reg 32 . pcInputAddr [31:0] $end
$var reg 5 / readReg1_t [4:0] $end
$var reg 1 0 regWrite $end
$var reg 1 1 writeReg_t $end
$scope module pc $end
$var wire 1 2 clk $end
$var wire 32 3 inAddr [31:0] $end
$var reg 32 4 con [31:0] $end
$var reg 32 5 outAddr [31:0] $end
$upscope $end
$scope module im $end
$var wire 32 6 inAddr [31:0] $end
$var wire 32 7 outContent [31:0] $end
$upscope $end
$scope module controlunit $end
$var wire 1 2 clk $end
$var wire 6 8 inCode [5:0] $end
$var wire 9 9 outCode [8:0] $end
$var reg 9 : result [8:0] $end
$upscope $end
$scope module mw4 $end
$var wire 5 ; in1 [4:0] $end
$var wire 5 < in2 [4:0] $end
$var wire 5 = out [4:0] $end
$var wire 1 > sl $end
$upscope $end
$scope module regHeap $end
$var wire 1 2 clk $end
$var wire 5 ? readReg1 [4:0] $end
$var wire 5 @ readReg2 [4:0] $end
$var wire 32 A reg1Data [31:0] $end
$var wire 32 B reg2Data [31:0] $end
$var wire 1 C regWrite $end
$var wire 32 D writeData [31:0] $end
$var wire 5 E writeReg [4:0] $end
$upscope $end
$scope module signext $end
$var wire 16 F in1 [15:0] $end
$var wire 32 G out [31:0] $end
$var wire 16 H temp [15:0] $end
$upscope $end
$scope module mw32 $end
$var wire 32 I in1 [31:0] $end
$var wire 32 J in2 [31:0] $end
$var wire 32 K out [31:0] $end
$var wire 1 L sl $end
$upscope $end
$scope module aluControl $end
$var wire 2 M aluop [1:0] $end
$var wire 1 2 clk $end
$var wire 6 N func [5:0] $end
$var reg 4 O aluctrl [3:0] $end
$upscope $end
$scope module alu $end
$var wire 1 2 clk $end
$var wire 4 P ctrl [3:0] $end
$var wire 32 Q in1 [31:0] $end
$var wire 32 R in2 [31:0] $end
$var wire 32 S out [31:0] $end
$var reg 32 T result [31:0] $end
$upscope $end
$scope module dm $end
$var wire 1 2 clk $end
$var wire 32 U inAddr [31:0] $end
$var wire 1 V memRead $end
$var wire 1 W memWrite $end
$var wire 32 X outData [31:0] $end
$var wire 32 Y writeData [31:0] $end
$upscope $end
$scope module mw32_2 $end
$var wire 32 Z in1 [31:0] $end
$var wire 32 [ in2 [31:0] $end
$var wire 32 \ out [31:0] $end
$var wire 1 ] sl $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
x]
b0x \
b0x [
b0 Z
bx Y
b0x X
xW
xV
b0 U
b0 T
b0 S
bx R
bx Q
bx P
bx O
bx N
bx M
xL
bx K
bx J
bx I
bx H
bx G
bx F
bx E
b0x D
xC
bx B
bx A
bx @
bx ?
x>
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
b0 4
b0 3
02
11
00
b1001 /
b0 .
0-
bx ,
b0x +
bx *
bx )
bx (
bx '
bx &
bx %
b0x $
bx #
bx "
b0 !
$end
#1
b0 H
b0 +
b0 D
b0 \
b0 $
b0 X
b0 [
b10 '
b10 K
b10 R
b1001 ,
b1001 =
b1001 E
b1 N
b1 F
b1 %
b1 G
b1 J
b1001 @
b10 *
b10 B
b10 I
b10 Y
b1010 ?
b10 )
b10 A
b10 Q
b0 <
b1001 ;
b100011 8
0]
0W
0V
b0 M
0L
0C
0>
b0 5
b10001101010010010000000000000001 &
b10001101010010010000000000000001 7
b0 (
b0 6
b0 :
b0 #
b0 9
b0 O
b0 "
b0 P
1-
12
#2
0-
02
#3
b11 +
b11 D
b11 \
b11 $
b11 X
b11 [
b1 '
b1 K
b1 R
1]
1V
1L
1C
b10 T
b10 !
b10 S
b10 U
b10 Z
b10 O
b10 "
b10 P
b11110000 :
b11110000 #
b11110000 9
1-
12
#4
0-
02
#5
b101 +
b101 D
b101 \
b101 $
b101 X
b101 [
b11 *
b11 B
b11 I
b11 Y
b11 T
b11 !
b11 S
b11 U
b11 Z
1-
12
#6
0-
02
#7
b101 *
b101 B
b101 I
b101 Y
1-
12
#8
0-
02
#9
1-
12
#10
0-
02
b1 .
b1 3
#11
b110000000100000 '
b110000000100000 K
b110000000100000 R
b100000 N
b110000000100000 F
b110000000100000 %
b110000000100000 G
b110000000100000 J
b1001 ?
b101 )
b101 A
b101 Q
b1100 <
b0 8
b1 5
b1001010010110000000100000 &
b1001010010110000000100000 7
b1 (
b1 6
1-
12
#12
0-
02
#13
b101 '
b101 K
b101 R
b1100 ,
b1100 =
b1100 E
b110000000100101 +
b110000000100101 D
b110000000100101 \
0]
0V
b10 M
0L
1>
b0 $
b0 X
b0 [
b100100010 :
b100100010 #
b100100010 9
b110000000100101 T
b110000000100101 !
b110000000100101 S
b110000000100101 U
b110000000100101 Z
1-
12
#14
0-
02
#15
b1010 +
b1010 D
b1010 \
b1010 T
b1010 !
b1010 S
b1010 U
b1010 Z
1-
12
#16
0-
02
#17
1-
12
#18
0-
02
#19
1-
12
#20
0-
02
b10 .
b10 3
#21
b1111111111111111 H
b11 '
b11 K
b11 R
b11111 ,
b11111 =
b11111 E
b1111100000100000 F
b11111111111111111111100000100000 %
b11111111111111111111100000100000 G
b11111111111111111111100000100000 J
b1011 @
b11 *
b11 B
b11 I
b11 Y
b1010 ?
b10 )
b10 A
b10 Q
b11111 <
b1011 ;
b10 5
b1010010111111100000100000 &
b1010010111111100000100000 7
b10 (
b10 6
1-
12
#22
0-
02
#23
b101 +
b101 D
b101 \
b101 T
b101 !
b101 S
b101 U
b101 Z
1-
12
#24
0-
02
#25
1-
12
#26
0-
02
#27
1-
12
#28
0-
02
#29
1-
12
#30
0-
02
#31
1-
12
#32
0-
02
#33
1-
12
#34
0-
02
#35
1-
12
#36
0-
02
#37
1-
12
#38
0-
02
#39
1-
12
#40
0-
02
#41
1-
12
#42
0-
02
#43
1-
12
#44
0-
02
#45
1-
12
#46
0-
02
#47
1-
12
#48
0-
02
#49
1-
12
#50
0-
02
