$date
	Tue May 17 15:12:25 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testBench $end
$var reg 1 ! clk $end
$scope module cpu $end
$var wire 32 " addBranchOut [31:0] $end
$var wire 32 # aluResult [31:0] $end
$var wire 4 $ aluctrl [3:0] $end
$var wire 1 % clk $end
$var wire 9 & ctrlUnitOutCode [8:0] $end
$var wire 32 ' dmOutData [31:0] $end
$var wire 32 ( extSign32 [31:0] $end
$var wire 32 ) imOutData [31:0] $end
$var wire 32 * mw32Out [31:0] $end
$var wire 32 + pcInputAddr [31:0] $end
$var wire 32 , pcOutAddr [31:0] $end
$var wire 32 - pcPlus4 [31:0] $end
$var wire 32 . reg1Data [31:0] $end
$var wire 32 / reg2Data [31:0] $end
$var wire 1 0 rst $end
$var wire 32 1 writeData [31:0] $end
$var wire 5 2 writeReg [4:0] $end
$var wire 1 3 zero $end
$scope module pc $end
$var wire 1 % clk $end
$var wire 32 4 inAddr [31:0] $end
$var wire 1 0 rst $end
$var reg 32 5 con [31:0] $end
$var reg 32 6 outAddr [31:0] $end
$upscope $end
$scope module add4 $end
$var wire 32 7 inAddr [31:0] $end
$var wire 32 8 outAddr [31:0] $end
$upscope $end
$scope module addBranch $end
$var wire 32 9 inAddr_add [31:0] $end
$var wire 32 : inAddr_sl2 [31:0] $end
$var wire 32 ; outAddr [31:0] $end
$upscope $end
$scope module mw32_3 $end
$var wire 32 < in1 [31:0] $end
$var wire 32 = in2 [31:0] $end
$var wire 32 > out [31:0] $end
$var wire 1 ? sl $end
$upscope $end
$scope module im $end
$var wire 32 @ inAddr [31:0] $end
$var wire 32 A outContent [31:0] $end
$upscope $end
$scope module controlunit $end
$var wire 1 B clk $end
$var wire 6 C inCode [5:0] $end
$var wire 9 D outCode [8:0] $end
$var reg 9 E result [8:0] $end
$upscope $end
$scope module mw4 $end
$var wire 5 F in1 [4:0] $end
$var wire 5 G in2 [4:0] $end
$var wire 5 H out [4:0] $end
$var wire 1 I sl $end
$upscope $end
$scope module regHeap $end
$var wire 1 % clk $end
$var wire 5 J readReg1 [4:0] $end
$var wire 5 K readReg2 [4:0] $end
$var wire 32 L reg1Data [31:0] $end
$var wire 32 M reg2Data [31:0] $end
$var wire 1 N regWrite $end
$var wire 32 O writeData [31:0] $end
$var wire 5 P writeReg [4:0] $end
$upscope $end
$scope module signext $end
$var wire 16 Q in1 [15:0] $end
$var wire 32 R out [31:0] $end
$var wire 16 S temp [15:0] $end
$upscope $end
$scope module mw32 $end
$var wire 32 T in1 [31:0] $end
$var wire 32 U in2 [31:0] $end
$var wire 32 V out [31:0] $end
$var wire 1 W sl $end
$upscope $end
$scope module aluControl $end
$var wire 2 X aluop [1:0] $end
$var wire 1 Y clk $end
$var wire 6 Z func [5:0] $end
$var reg 4 [ aluctrl [3:0] $end
$upscope $end
$scope module alu $end
$var wire 1 \ clk $end
$var wire 4 ] ctrl [3:0] $end
$var wire 32 ^ in1 [31:0] $end
$var wire 32 _ in2 [31:0] $end
$var wire 32 ` out [31:0] $end
$var reg 32 a result [31:0] $end
$var reg 1 b zero $end
$upscope $end
$scope module dm $end
$var wire 1 % clk $end
$var wire 32 c inAddr [31:0] $end
$var wire 1 d memRead $end
$var wire 1 e memWrite $end
$var wire 32 f outData [31:0] $end
$var wire 32 g writeData [31:0] $end
$upscope $end
$scope module mw32_2 $end
$var wire 32 h in1 [31:0] $end
$var wire 32 i in2 [31:0] $end
$var wire 32 j out [31:0] $end
$var wire 1 k sl $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0k
b0 j
b0 i
b0 h
b100 g
b0 f
0e
0d
b0 c
1b
b0 a
b0 `
b100 _
b100 ^
b110 ]
z\
b110 [
b10 Z
zY
b1 X
0W
b100 V
b10 U
b100 T
b0 S
b10 R
b10 Q
b1001 P
b0 O
0N
b100 M
b100 L
b1001 K
b1000 J
0I
b1001 H
b0 G
b1001 F
b101 E
b101 D
b100 C
zB
b10001000010010000000000000010 A
b0 @
1?
b1100 >
b1100 =
b100 <
b1100 ;
b1000 :
b100 9
b100 8
b0 7
b0 6
b0 5
b1100 4
13
b1001 2
b0 1
00
b100 /
b100 .
b100 -
b0 ,
b1100 +
b100 *
b10001000010010000000000000010 )
b10 (
b0 '
b101 &
0%
b110 $
b0 #
b1100 "
0!
$end
#1
b1100 5
#10
b10 [
b10 $
b10 ]
b10 X
1N
1I
b100100010 E
b100100010 &
b100100010 D
0?
b110 1
b110 O
b110 j
0b
03
b110 a
b110 #
b110 `
b110 c
b110 h
b10 *
b10 V
b10 _
b1000 2
b1000 H
b1000 P
b10000 +
b10000 4
b10000 >
b10000 -
b10000 8
b10000 9
b10000 <
b0 C
b1010 K
b10 /
b10 M
b10 T
b10 g
b1001 J
b1010 F
b1000 G
b100000 Z
b100000000100000 Q
b10000000010000000 :
b10000000010010000 "
b10000000010010000 ;
b10000000010010000 =
b100000000100000 (
b100000000100000 R
b100000000100000 U
b1100 6
b1001010100100000000100000 )
b1001010100100000000100000 A
b1100 ,
b1100 7
b1100 @
1!
1%
#11
b10000 5
#20
0!
0%
#30
b0 X
0N
0I
b0 E
b0 &
b0 D
b10 [
b10 $
b10 ]
bx 1
bx O
bx j
bx S
b10100 +
b10100 4
b10100 >
bx *
bx V
bx _
xb
x3
bx a
bx #
bx `
bx c
bx h
bx 2
bx H
bx P
b10100 -
b10100 8
b10100 9
b10100 <
bx C
bx K
bx /
bx M
bx T
bx g
bx J
bx .
bx L
bx ^
bx F
bx G
bx Z
bx Q
bx :
bx "
bx ;
bx =
bx (
bx R
bx U
b10000 6
bx )
bx A
b10000 ,
b10000 7
b10000 @
1!
1%
#31
b10100 5
#40
0!
0%
#50
b11000 +
b11000 4
b11000 >
b11000 -
b11000 8
b11000 9
b11000 <
b10100 6
b10100 ,
b10100 7
b10100 @
1!
1%
#51
b11000 5
#60
0!
0%
#70
b11100 +
b11100 4
b11100 >
b11100 -
b11100 8
b11100 9
b11100 <
b11000 6
b11000 ,
b11000 7
b11000 @
1!
1%
#71
b11100 5
#80
0!
0%
#90
b100000 +
b100000 4
b100000 >
b100000 -
b100000 8
b100000 9
b100000 <
b11100 6
b11100 ,
b11100 7
b11100 @
1!
1%
#91
b100000 5
#100
0!
0%
