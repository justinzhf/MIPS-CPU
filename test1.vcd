$date
	Tue May 17 09:23:53 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testBench $end
$var reg 1 ! clk $end
$var reg 32 " inAddr [31:0] $end
$scope module cpu $end
$var wire 32 # addBranchOut [31:0] $end
$var wire 32 $ aluResult [31:0] $end
$var wire 4 % aluctrl [3:0] $end
$var wire 1 & clk $end
$var wire 9 ' ctrlUnitOutCode [8:0] $end
$var wire 32 ( dmOutData [31:0] $end
$var wire 32 ) extSign32 [31:0] $end
$var wire 32 * imOutData [31:0] $end
$var wire 32 + mw32Out [31:0] $end
$var wire 32 , pcInputAddr [31:0] $end
$var wire 32 - pcOutAddr [31:0] $end
$var wire 32 . pcPlus4 [31:0] $end
$var wire 32 / reg1Data [31:0] $end
$var wire 32 0 reg2Data [31:0] $end
$var wire 32 1 writeData [31:0] $end
$var wire 5 2 writeReg [4:0] $end
$var wire 1 3 zero $end
$scope module pc $end
$var wire 1 & clk $end
$var wire 32 4 inAddr [31:0] $end
$var reg 32 5 con [31:0] $end
$var reg 32 6 outAddr [31:0] $end
$upscope $end
$scope module add4 $end
$var wire 32 7 inAddr [31:0] $end
$var wire 32 8 outAddr [31:0] $end
$upscope $end
$scope module addBranch $end
$var wire 32 9 inAddr_add [31:0] $end
$var wire 32 : inAddr_sl2 [31:0] $end
$var wire 32 ; outAddr [31:0] $end
$upscope $end
$scope module mw32_3 $end
$var wire 32 < in1 [31:0] $end
$var wire 32 = in2 [31:0] $end
$var wire 32 > out [31:0] $end
$var wire 1 ? sl $end
$upscope $end
$scope module im $end
$var wire 32 @ inAddr [31:0] $end
$var wire 32 A outContent [31:0] $end
$upscope $end
$scope module controlunit $end
$var wire 1 B clk $end
$var wire 6 C inCode [5:0] $end
$var wire 9 D outCode [8:0] $end
$var reg 9 E result [8:0] $end
$upscope $end
$scope module mw4 $end
$var wire 5 F in1 [4:0] $end
$var wire 5 G in2 [4:0] $end
$var wire 5 H out [4:0] $end
$var wire 1 I sl $end
$upscope $end
$scope module regHeap $end
$var wire 1 & clk $end
$var wire 5 J readReg1 [4:0] $end
$var wire 5 K readReg2 [4:0] $end
$var wire 32 L reg1Data [31:0] $end
$var wire 32 M reg2Data [31:0] $end
$var wire 1 N regWrite $end
$var wire 32 O writeData [31:0] $end
$var wire 5 P writeReg [4:0] $end
$upscope $end
$scope module signext $end
$var wire 16 Q in1 [15:0] $end
$var wire 32 R out [31:0] $end
$var wire 16 S temp [15:0] $end
$upscope $end
$scope module mw32 $end
$var wire 32 T in1 [31:0] $end
$var wire 32 U in2 [31:0] $end
$var wire 32 V out [31:0] $end
$var wire 1 W sl $end
$upscope $end
$scope module aluControl $end
$var wire 2 X aluop [1:0] $end
$var wire 1 Y clk $end
$var wire 6 Z func [5:0] $end
$var reg 4 [ aluctrl [3:0] $end
$upscope $end
$scope module alu $end
$var wire 1 \ clk $end
$var wire 4 ] ctrl [3:0] $end
$var wire 32 ^ in1 [31:0] $end
$var wire 32 _ in2 [31:0] $end
$var wire 32 ` out [31:0] $end
$var reg 32 a result [31:0] $end
$var reg 1 b zero $end
$upscope $end
$scope module dm $end
$var wire 1 & clk $end
$var wire 32 c inAddr [31:0] $end
$var wire 1 d memRead $end
$var wire 1 e memWrite $end
$var wire 32 f outData [31:0] $end
$var wire 32 g writeData [31:0] $end
$upscope $end
$scope module mw32_2 $end
$var wire 32 h in1 [31:0] $end
$var wire 32 i in2 [31:0] $end
$var wire 32 j out [31:0] $end
$var wire 1 k sl $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0k
bx j
b0 i
bx h
bx g
b0 f
0e
0d
bx c
xb
bx a
bx `
bx _
bx ^
b10 ]
z\
b10 [
bx Z
zY
b0 X
0W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
0N
bx M
bx L
bx K
bx J
0I
bx H
bx G
bx F
b0 E
b0 D
bx C
zB
bx A
bx @
0?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
b0 5
bx 4
x3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
b0 (
b0 '
x&
b10 %
bx $
bx #
bx "
x!
$end
#10
1!
1&
b0 "
#20
0!
0&
#30
1!
1&
#40
0!
0&
#50
1!
1&
#60
0!
0&
#70
1!
1&
#80
0!
0&
#90
1!
1&
#100
0!
0&
#110
1!
1&
