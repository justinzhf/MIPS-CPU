$date
	Mon May 16 19:16:02 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testBench $end
$var wire 32 ! aluResult [31:0] $end
$var wire 4 " aluctrl [3:0] $end
$var wire 9 # ctrlUnitOutCode [8:0] $end
$var wire 32 $ extSign32 [31:0] $end
$var wire 32 % imOutData [31:0] $end
$var wire 32 & mw32Out [31:0] $end
$var wire 32 ' pcOutAddr [31:0] $end
$var wire 32 ( reg1Data [31:0] $end
$var wire 32 ) reg2Data [31:0] $end
$var wire 5 * writeReg [4:0] $end
$var reg 1 + clk $end
$var reg 32 , pcInputAddr [31:0] $end
$var reg 1 - regWrite $end
$var reg 32 . writeData [31:0] $end
$scope module pc $end
$var wire 1 / clk $end
$var wire 32 0 inAddr [31:0] $end
$var reg 32 1 con [31:0] $end
$var reg 32 2 outAddr [31:0] $end
$upscope $end
$scope module im $end
$var wire 32 3 inAddr [31:0] $end
$var wire 32 4 outContent [31:0] $end
$var integer 32 5 i [31:0] $end
$upscope $end
$scope module controlunit $end
$var wire 1 / clk $end
$var wire 6 6 inCode [5:0] $end
$var wire 9 7 outCode [8:0] $end
$var reg 9 8 result [8:0] $end
$upscope $end
$scope module mw4 $end
$var wire 5 9 in1 [4:0] $end
$var wire 5 : in2 [4:0] $end
$var wire 5 ; out [4:0] $end
$var wire 1 < sl $end
$upscope $end
$scope module regHeap $end
$var wire 1 / clk $end
$var wire 5 = readReg1 [4:0] $end
$var wire 5 > readReg2 [4:0] $end
$var wire 32 ? reg1Data [31:0] $end
$var wire 32 @ reg2Data [31:0] $end
$var wire 1 A regWrite $end
$var wire 32 B writeData [31:0] $end
$var wire 5 C writeReg [4:0] $end
$upscope $end
$scope module signext $end
$var wire 16 D in1 [15:0] $end
$var wire 32 E out [31:0] $end
$var wire 16 F temp [15:0] $end
$upscope $end
$scope module mw32 $end
$var wire 32 G in1 [31:0] $end
$var wire 32 H in2 [31:0] $end
$var wire 32 I out [31:0] $end
$var wire 1 J sl $end
$upscope $end
$scope module aluControl $end
$var wire 2 K aluop [1:0] $end
$var wire 1 / clk $end
$var wire 6 L func [5:0] $end
$var reg 4 M aluctrl [3:0] $end
$upscope $end
$scope module alu $end
$var wire 1 / clk $end
$var wire 4 N ctrl [3:0] $end
$var wire 32 O in1 [31:0] $end
$var wire 32 P in2 [31:0] $end
$var wire 32 Q out [31:0] $end
$var reg 32 R result [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 R
b0 Q
bx P
bx O
bx N
bx M
bx L
bx K
xJ
bx I
bx H
bx G
bx F
bx E
bx D
bx C
b110 B
0A
bx @
bx ?
bx >
bx =
x<
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
b1000 5
bx 4
bx 3
bx 2
b0 1
b0 0
0/
b110 .
0-
b0 ,
0+
bx *
bx )
bx (
bx '
bx &
bx %
bx $
bx #
bx "
b0 !
$end
#1
b1111111111111111 F
b11 &
b11 I
b11 P
b1011 *
b1011 ;
b1011 C
b100000 L
b1111100000100000 D
b11111111111111111111100000100000 $
b11111111111111111111100000100000 E
b11111111111111111111100000100000 H
b1011 >
b11 )
b11 @
b11 G
b1010 =
b100 (
b100 ?
b100 O
b11111 :
b1011 9
b0 6
b0 K
0J
0<
b0 2
b1010010111111100000100000 %
b1010010111111100000100000 4
b0 '
b0 3
b0 8
b0 #
b0 7
b0 M
b0 "
b0 N
1+
1/
#2
0+
0/
#3
b11111 *
b11111 ;
b11111 C
b10 K
1<
b10 M
b10 "
b10 N
b100100010 8
b100100010 #
b100100010 7
1+
1/
#4
0+
0/
#5
b111 R
b111 !
b111 Q
1+
1/
#6
0+
0/
#7
1+
1/
#8
0+
0/
#9
1+
1/
#10
0+
0/
#11
1+
1/
#12
0+
0/
#13
1+
1/
#14
0+
0/
#15
1+
1/
#16
0+
0/
#17
1+
1/
#18
0+
0/
#19
1+
1/
#20
0+
0/
b1 ,
b1 0
#21
b0 F
b1001 *
b1001 ;
b1001 C
b100010 L
b100100000100010 D
b100100000100010 $
b100100000100010 E
b100100000100010 H
b1001 :
b1 2
b1010010110100100000100010 %
b1010010110100100000100010 4
b1 '
b1 3
1+
1/
#22
0+
0/
#23
b110 M
b110 "
b110 N
1+
1/
#24
0+
0/
#25
b1 R
b1 !
b1 Q
1+
1/
#26
0+
0/
#27
1+
1/
#28
0+
0/
#29
1+
1/
#30
0+
0/
b10 ,
b10 0
#31
b0 &
b0 I
b0 P
b0 *
b0 ;
b0 C
b11 L
b11 D
b11 $
b11 E
b11 H
b0 >
b0 )
b0 @
b0 G
b0 =
b0 (
b0 ?
b0 O
b0 :
b0 9
b101011 6
b10 2
b10101100000000000000000000000011 %
b10101100000000000000000000000011 4
b10 '
b10 3
1+
1/
#32
0+
0/
#33
b11 &
b11 I
b11 P
b0 K
1J
0<
b10001000 8
b10001000 #
b10001000 7
b0 M
b0 "
b0 N
b0 R
b0 !
b0 Q
1+
1/
#34
0+
0/
#35
b10 M
b10 "
b10 N
1+
1/
#36
0+
0/
#37
b11 R
b11 !
b11 Q
1+
1/
#38
0+
0/
#39
1+
1/
#40
0+
0/
b11 ,
b11 0
#41
b101 &
b101 I
b101 P
b101 L
b101 D
b101 $
b101 E
b101 H
b100 6
b11 2
b10000000000000000000000000101 %
b10000000000000000000000000101 4
b11 '
b11 3
1+
1/
#42
0+
0/
#43
b0 &
b0 I
b0 P
b1 K
0J
b101 R
b101 !
b101 Q
b101 8
b101 #
b101 7
1+
1/
#44
0+
0/
#45
b110 M
b110 "
b110 N
b0 R
b0 !
b0 Q
1+
1/
#46
0+
0/
#47
1+
1/
#48
0+
0/
#49
1+
1/
#50
0+
0/
b101 ,
b101 0
#51
b1001 L
b1001 D
b1001 $
b1001 E
b1001 H
b0 6
b101 2
b1001 %
b1001 4
b101 '
b101 3
1+
1/
#52
0+
0/
#53
b10 K
1<
b100100010 8
b100100010 #
b100100010 7
1+
1/
#54
0+
0/
#55
b0 M
b0 "
b0 N
1+
1/
#56
0+
0/
#57
1+
1/
#58
0+
0/
#59
1+
1/
#60
0+
0/
