$date
	Mon May 16 22:10:30 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testBench $end
$var wire 32 ! aluResult [31:0] $end
$var wire 4 " aluctrl [3:0] $end
$var wire 9 # ctrlUnitOutCode [8:0] $end
$var wire 32 $ dmOutData [31:0] $end
$var wire 32 % extSign32 [31:0] $end
$var wire 32 & imOutData [31:0] $end
$var wire 32 ' mw32Out [31:0] $end
$var wire 32 ( pcOutAddr [31:0] $end
$var wire 32 ) reg1Data [31:0] $end
$var wire 32 * reg2Data [31:0] $end
$var wire 32 + writeData [31:0] $end
$var wire 5 , writeReg [4:0] $end
$var reg 1 - clk $end
$var reg 32 . pcInputAddr [31:0] $end
$var reg 5 / readReg1_t [4:0] $end
$var reg 1 0 regWrite $end
$var reg 1 1 writeReg_t $end
$scope module pc $end
$var wire 1 2 clk $end
$var wire 32 3 inAddr [31:0] $end
$var reg 32 4 con [31:0] $end
$var reg 32 5 outAddr [31:0] $end
$upscope $end
$scope module im $end
$var wire 32 6 inAddr [31:0] $end
$var wire 32 7 outContent [31:0] $end
$upscope $end
$scope module controlunit $end
$var wire 1 8 clk $end
$var wire 6 9 inCode [5:0] $end
$var wire 9 : outCode [8:0] $end
$var reg 9 ; result [8:0] $end
$upscope $end
$scope module mw4 $end
$var wire 5 < in1 [4:0] $end
$var wire 5 = in2 [4:0] $end
$var wire 5 > out [4:0] $end
$var wire 1 ? sl $end
$upscope $end
$scope module regHeap $end
$var wire 1 2 clk $end
$var wire 5 @ readReg1 [4:0] $end
$var wire 5 A readReg2 [4:0] $end
$var wire 32 B reg1Data [31:0] $end
$var wire 32 C reg2Data [31:0] $end
$var wire 1 D regWrite $end
$var wire 32 E writeData [31:0] $end
$var wire 5 F writeReg [4:0] $end
$upscope $end
$scope module signext $end
$var wire 16 G in1 [15:0] $end
$var wire 32 H out [31:0] $end
$var wire 16 I temp [15:0] $end
$upscope $end
$scope module mw32 $end
$var wire 32 J in1 [31:0] $end
$var wire 32 K in2 [31:0] $end
$var wire 32 L out [31:0] $end
$var wire 1 M sl $end
$upscope $end
$scope module aluControl $end
$var wire 2 N aluop [1:0] $end
$var wire 1 2 clk $end
$var wire 6 O func [5:0] $end
$var reg 4 P aluctrl [3:0] $end
$upscope $end
$scope module alu $end
$var wire 1 Q clk $end
$var wire 4 R ctrl [3:0] $end
$var wire 32 S in1 [31:0] $end
$var wire 32 T in2 [31:0] $end
$var wire 32 U out [31:0] $end
$var reg 32 V result [31:0] $end
$upscope $end
$scope module dm $end
$var wire 1 2 clk $end
$var wire 32 W inAddr [31:0] $end
$var wire 1 X memRead $end
$var wire 1 Y memWrite $end
$var wire 32 Z outData [31:0] $end
$var wire 32 [ writeData [31:0] $end
$upscope $end
$scope module mw32_2 $end
$var wire 32 \ in1 [31:0] $end
$var wire 32 ] in2 [31:0] $end
$var wire 32 ^ out [31:0] $end
$var wire 1 _ sl $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0_
b0 ^
b0 ]
b0 \
bx [
b0 Z
0Y
0X
b0 W
b0 V
b0 U
bx T
bx S
bx R
zQ
bx P
bx O
b0 N
0M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
b0 E
0D
bx C
bx B
bx A
bx @
0?
bx >
bx =
bx <
b0 ;
b0 :
bx 9
z8
bx 7
bx 6
bx 5
b0 4
b0 3
02
11
00
b1001 /
b0 .
0-
bx ,
b0 +
bx *
bx )
bx (
bx '
bx &
bx %
b0 $
b0 #
bx "
b0 !
$end
#10
b111 $
b111 Z
b111 ]
1_
1X
1M
1D
b111 +
b111 E
b111 ^
b11110000 ;
b11110000 #
b11110000 :
b10 V
b10 !
b10 U
b10 W
b10 \
b0 I
b1 '
b1 L
b1 T
b1001 ,
b1001 >
b1001 F
b1 O
b1 G
b1 %
b1 H
b1 K
b1001 A
b10 *
b10 C
b10 J
b10 [
b1000 @
b1 )
b1 B
b1 S
b0 =
b1001 <
b100011 9
b0 5
b10001101000010010000000000000001 &
b10001101000010010000000000000001 7
b0 (
b0 6
b10 P
b10 "
b10 R
1-
12
#20
0-
02
b1 .
b1 3
#30
b10 +
b10 E
b10 ^
b0 $
b0 Z
b0 ]
0_
1Y
0X
0D
b10001000 ;
b10001000 #
b10001000 :
b101011 9
b111 *
b111 C
b111 J
b111 [
b1 5
b10101101000010010000000000000001 &
b10101101000010010000000000000001 7
b1 (
b1 6
1-
12
#40
0-
02
b10 .
b10 3
#50
b111 +
b111 E
b111 ^
b111 $
b111 Z
b111 ]
1_
0Y
1X
1D
b11110000 ;
b11110000 #
b11110000 :
b1010 ,
b1010 >
b1010 F
b1010 A
b10 *
b10 C
b10 J
b10 [
b1010 <
b100011 9
b10 5
b10001101000010100000000000000001 &
b10001101000010100000000000000001 7
b10 (
b10 6
1-
12
#60
0-
02
b11 .
b11 3
#70
b1110 +
b1110 E
b1110 ^
b1011 ,
b1011 >
b1011 F
b0 $
b0 Z
b0 ]
0_
0X
b10 N
0M
1?
b1110 V
b1110 !
b1110 U
b1110 W
b1110 \
b100100010 ;
b100100010 #
b100100010 :
b111 '
b111 L
b111 T
b100000 O
b101100000100000 G
b101100000100000 %
b101100000100000 H
b101100000100000 K
b1010 @
b111 )
b111 B
b111 S
b1011 =
b0 9
b111 *
b111 C
b111 J
b111 [
b11 5
b1010010100101100000100000 &
b1010010100101100000100000 7
b11 (
b11 6
1-
12
#80
0-
02
#90
1-
12
#100
0-
02
