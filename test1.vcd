$date
	Tue May 17 07:28:51 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testBench $end
$var wire 32 ! addBranchOut [31:0] $end
$var wire 32 " aluResult [31:0] $end
$var wire 4 # aluctrl [3:0] $end
$var wire 9 $ ctrlUnitOutCode [8:0] $end
$var wire 32 % dmOutData [31:0] $end
$var wire 32 & extSign32 [31:0] $end
$var wire 32 ' imOutData [31:0] $end
$var wire 32 ( mw32Out [31:0] $end
$var wire 32 ) pcOutAddr [31:0] $end
$var wire 32 * pcPlus4 [31:0] $end
$var wire 32 + reg1Data [31:0] $end
$var wire 32 , reg2Data [31:0] $end
$var wire 32 - writeData [31:0] $end
$var wire 5 . writeReg [4:0] $end
$var reg 1 / clk $end
$var reg 32 0 pcInputAddr [31:0] $end
$var reg 5 1 readReg1_t [4:0] $end
$var reg 1 2 regWrite $end
$var reg 1 3 writeReg_t $end
$scope module pc $end
$var wire 1 4 clk $end
$var wire 32 5 inAddr [31:0] $end
$var reg 32 6 con [31:0] $end
$var reg 32 7 outAddr [31:0] $end
$upscope $end
$scope module add4 $end
$var wire 32 8 inAddr [31:0] $end
$var wire 32 9 outAddr [31:0] $end
$upscope $end
$scope module addBranch $end
$var wire 32 : inAddr_add [31:0] $end
$var wire 32 ; inAddr_sl2 [31:0] $end
$var wire 32 < outAddr [31:0] $end
$upscope $end
$scope module im $end
$var wire 32 = inAddr [31:0] $end
$var wire 32 > outContent [31:0] $end
$upscope $end
$scope module controlunit $end
$var wire 1 ? clk $end
$var wire 6 @ inCode [5:0] $end
$var wire 9 A outCode [8:0] $end
$var reg 9 B result [8:0] $end
$upscope $end
$scope module mw4 $end
$var wire 5 C in1 [4:0] $end
$var wire 5 D in2 [4:0] $end
$var wire 5 E out [4:0] $end
$var wire 1 F sl $end
$upscope $end
$scope module regHeap $end
$var wire 1 4 clk $end
$var wire 5 G readReg1 [4:0] $end
$var wire 5 H readReg2 [4:0] $end
$var wire 32 I reg1Data [31:0] $end
$var wire 32 J reg2Data [31:0] $end
$var wire 1 K regWrite $end
$var wire 32 L writeData [31:0] $end
$var wire 5 M writeReg [4:0] $end
$upscope $end
$scope module signext $end
$var wire 16 N in1 [15:0] $end
$var wire 32 O out [31:0] $end
$var wire 16 P temp [15:0] $end
$upscope $end
$scope module mw32 $end
$var wire 32 Q in1 [31:0] $end
$var wire 32 R in2 [31:0] $end
$var wire 32 S out [31:0] $end
$var wire 1 T sl $end
$upscope $end
$scope module aluControl $end
$var wire 2 U aluop [1:0] $end
$var wire 1 4 clk $end
$var wire 6 V func [5:0] $end
$var reg 4 W aluctrl [3:0] $end
$upscope $end
$scope module alu $end
$var wire 1 X clk $end
$var wire 4 Y ctrl [3:0] $end
$var wire 32 Z in1 [31:0] $end
$var wire 32 [ in2 [31:0] $end
$var wire 32 \ out [31:0] $end
$var reg 32 ] result [31:0] $end
$upscope $end
$scope module dm $end
$var wire 1 4 clk $end
$var wire 32 ^ inAddr [31:0] $end
$var wire 1 _ memRead $end
$var wire 1 ` memWrite $end
$var wire 32 a outData [31:0] $end
$var wire 32 b writeData [31:0] $end
$upscope $end
$scope module mw32_2 $end
$var wire 32 c in1 [31:0] $end
$var wire 32 d in2 [31:0] $end
$var wire 32 e out [31:0] $end
$var wire 1 f sl $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0f
b0 e
b0 d
b0 c
bx b
b0 a
0`
0_
b0 ^
b0 ]
b0 \
bx [
bx Z
bx Y
zX
bx W
bx V
b0 U
0T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
b0 L
0K
bx J
bx I
bx H
bx G
0F
bx E
bx D
bx C
b0 B
b0 A
bx @
z?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
b0 6
b0 5
04
13
02
b1001 1
b0 0
0/
bx .
b0 -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
b0 %
b0 $
bx #
b0 "
bx !
$end
#10
b1000 %
b1000 a
b1000 d
1f
1_
1T
1K
b1000 -
b1000 L
b1000 e
b11110000 B
b11110000 $
b11110000 A
b100 ]
b100 "
b100 \
b100 ^
b100 c
b1000 ;
b1100 !
b1100 <
b0 P
b10 (
b10 S
b10 [
b1001 .
b1001 E
b1001 M
b100 *
b100 9
b100 :
b100011 @
b1001 H
b10 ,
b10 J
b10 Q
b10 b
b1010 G
b10 +
b10 I
b10 Z
b1001 C
b0 D
b10 V
b10 N
b10 &
b10 O
b10 R
b0 7
b10001101010010010000000000000010 '
b10001101010010010000000000000010 >
b0 )
b0 8
b0 =
b10 W
b10 #
b10 Y
1/
14
#20
0/
04
b100 0
b100 5
#30
b101 -
b101 L
b101 e
0f
1`
0_
0K
b0 %
b0 a
b0 d
b10001000 B
b10001000 $
b10001000 A
b101 ]
b101 "
b101 \
b101 ^
b101 c
b1 (
b1 S
b1 [
b1000 *
b1000 9
b1000 :
b101011 @
b1000 G
b100 +
b100 I
b100 Z
b1 V
b1 N
b100 ;
b1100 !
b1100 <
b1 &
b1 O
b1 R
b1000 ,
b1000 J
b1000 Q
b1000 b
b100 7
b10101101000010010000000000000001 '
b10101101000010010000000000000001 >
b100 )
b100 8
b100 =
1/
14
#40
0/
04
b1000 0
b1000 5
#50
b1000 -
b1000 L
b1000 e
b1000 %
b1000 a
b1000 d
1f
0`
1_
1K
b11110000 B
b11110000 $
b11110000 A
b1010 .
b1010 E
b1010 M
b10000 !
b10000 <
b1100 *
b1100 9
b1100 :
b100011 @
b1010 H
b10 ,
b10 J
b10 Q
b10 b
b1010 C
b1000 7
b10001101000010100000000000000001 '
b10001101000010100000000000000001 >
b1000 )
b1000 8
b1000 =
1/
14
#60
0/
04
b1100 0
b1100 5
#70
b1011 .
b1011 E
b1011 M
b10000 -
b10000 L
b10000 e
0f
0_
b10 U
0T
1F
b0 %
b0 a
b0 d
b100100010 B
b100100010 $
b100100010 A
b10000 ]
b10000 "
b10000 \
b10000 ^
b10000 c
b1000 (
b1000 S
b1000 [
b10000 *
b10000 9
b10000 :
b0 @
b1010 G
b1000 +
b1000 I
b1000 Z
b1011 D
b100000 V
b101100000100000 N
b10110000010000000 ;
b10110000010010000 !
b10110000010010000 <
b101100000100000 &
b101100000100000 O
b101100000100000 R
b1000 ,
b1000 J
b1000 Q
b1000 b
b1100 7
b1010010100101100000100000 '
b1010010100101100000100000 >
b1100 )
b1100 8
b1100 =
1/
14
#80
0/
04
#90
1/
14
#100
0/
04
